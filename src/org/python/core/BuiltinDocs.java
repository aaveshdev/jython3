// generated by make_pydocs.py

package org.python.core;

public class BuiltinDocs {

    // Docs for <type 'object'>
    public final static String object___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String object___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String object_doc = 
        "The most base type";

    public final static String object___format___doc = 
        "default object formatter";

    public final static String object___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String object___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String object___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String object___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String object___reduce___doc = 
        "helper for pickle";

    public final static String object___reduce_ex___doc = 
        "helper for pickle";

    public final static String object___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String object___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String object___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String object___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String object___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <type 'type'>
    public final static String type___abstractmethods___doc = 
        "";

    public final static String type___base___doc = 
        "The most base type";

    public final static String type___bases___doc = 
        "tuple() -> empty tuple\n" + 
        "tuple(iterable) -> tuple initialized from iterable's items\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String type___basicsize___doc = 
        "int(x[, base]) -> integer\n" + 
        "\n" + 
        "Convert a string or number to an integer, if possible.  A floating point\n" + 
        "argument will be truncated towards zero (this does not include a string\n" + 
        "representation of a floating point number!)  When converting a string, use\n" + 
        "the optional base.  It is an error to supply a base when converting a\n" + 
        "non-string.  If base is zero, the proper base is guessed based on the\n" + 
        "string content.  If the argument is outside the integer range a\n" + 
        "long object will be returned instead.";

    public final static String type___call___doc = 
        "x.__call__(...) <==> x(...)";

    public final static String type___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String type___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String type___dict___doc = 
        "";

    public final static String type___dictoffset___doc = 
        "int(x[, base]) -> integer\n" + 
        "\n" + 
        "Convert a string or number to an integer, if possible.  A floating point\n" + 
        "argument will be truncated towards zero (this does not include a string\n" + 
        "representation of a floating point number!)  When converting a string, use\n" + 
        "the optional base.  It is an error to supply a base when converting a\n" + 
        "non-string.  If base is zero, the proper base is guessed based on the\n" + 
        "string content.  If the argument is outside the integer range a\n" + 
        "long object will be returned instead.";

    public final static String type_doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String type___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String type___flags___doc = 
        "int(x[, base]) -> integer\n" + 
        "\n" + 
        "Convert a string or number to an integer, if possible.  A floating point\n" + 
        "argument will be truncated towards zero (this does not include a string\n" + 
        "representation of a floating point number!)  When converting a string, use\n" + 
        "the optional base.  It is an error to supply a base when converting a\n" + 
        "non-string.  If base is zero, the proper base is guessed based on the\n" + 
        "string content.  If the argument is outside the integer range a\n" + 
        "long object will be returned instead.";

    public final static String type___format___doc = 
        "default object formatter";

    public final static String type___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String type___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String type___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String type___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String type___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String type___instancecheck___doc = 
        "__instancecheck__() -> bool\n" + 
        "check if an object is an instance";

    public final static String type___itemsize___doc = 
        "int(x[, base]) -> integer\n" + 
        "\n" + 
        "Convert a string or number to an integer, if possible.  A floating point\n" + 
        "argument will be truncated towards zero (this does not include a string\n" + 
        "representation of a floating point number!)  When converting a string, use\n" + 
        "the optional base.  It is an error to supply a base when converting a\n" + 
        "non-string.  If base is zero, the proper base is guessed based on the\n" + 
        "string content.  If the argument is outside the integer range a\n" + 
        "long object will be returned instead.";

    public final static String type___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String type___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String type___module___doc = 
        "str(object) -> string\n" + 
        "\n" + 
        "Return a nice string representation of the object.\n" + 
        "If the argument is a string, the return value is the same object.";

    public final static String type___mro___doc = 
        "tuple() -> empty tuple\n" + 
        "tuple(iterable) -> tuple initialized from iterable's items\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String type___name___doc = 
        "str(object) -> string\n" + 
        "\n" + 
        "Return a nice string representation of the object.\n" + 
        "If the argument is a string, the return value is the same object.";

    public final static String type___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String type___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String type___reduce___doc = 
        "helper for pickle";

    public final static String type___reduce_ex___doc = 
        "helper for pickle";

    public final static String type___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String type___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String type___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String type___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String type___subclasscheck___doc = 
        "__subclasscheck__() -> bool\n" + 
        "check if a class is a subclass";

    public final static String type___subclasses___doc = 
        "__subclasses__() -> list of immediate subclasses";

    public final static String type___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String type___weakrefoffset___doc = 
        "int(x[, base]) -> integer\n" + 
        "\n" + 
        "Convert a string or number to an integer, if possible.  A floating point\n" + 
        "argument will be truncated towards zero (this does not include a string\n" + 
        "representation of a floating point number!)  When converting a string, use\n" + 
        "the optional base.  It is an error to supply a base when converting a\n" + 
        "non-string.  If base is zero, the proper base is guessed based on the\n" + 
        "string content.  If the argument is outside the integer range a\n" + 
        "long object will be returned instead.";

    public final static String type_mro_doc = 
        "mro() -> list\n" + 
        "return a type's method resolution order";

    // Docs for <type 'unicode'>
    public final static String unicode___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String unicode___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String unicode___contains___doc = 
        "x.__contains__(y) <==> y in x";

    public final static String unicode___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String unicode_doc = 
        "unicode(object='') -> unicode object\n" +
        "unicode(string[, encoding[, errors]]) -> unicode object\n" + 
        "\n" + 
        "Create a new Unicode object from the given encoded string.\n" + 
        "encoding defaults to the current default string encoding.\n" + 
        "errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.";

    public final static String unicode___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String unicode___format___doc = 
        "S.__format__(format_spec) -> unicode\n" + 
        "\n" + 
        "Return a formatted version of S as described by format_spec.";

    public final static String unicode___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String unicode___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String unicode___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String unicode___getnewargs___doc = 
        "";

    public final static String unicode___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String unicode___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String unicode___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String unicode___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String unicode___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String unicode___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String unicode___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String unicode___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String unicode___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String unicode___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String unicode___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String unicode___reduce___doc = 
        "helper for pickle";

    public final static String unicode___reduce_ex___doc = 
        "helper for pickle";

    public final static String unicode___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String unicode___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String unicode___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String unicode___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String unicode___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes\n" + 
        "\n" + 
        "";

    public final static String unicode___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String unicode___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String unicode__formatter_field_name_split_doc = 
        "";

    public final static String unicode__formatter_parser_doc = 
        "";

    public final static String unicode_capitalize_doc = 
        "S.capitalize() -> unicode\n" + 
        "\n" + 
        "Return a capitalized version of S, i.e. make the first character\n" + 
        "have upper case and the rest lower case.";

    public final static String unicode_center_doc = 
        "S.center(width[, fillchar]) -> unicode\n" + 
        "\n" + 
        "Return S centered in a Unicode string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String unicode_count_doc = 
        "S.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of substring sub in\n" + 
        "Unicode string S[start:end].  Optional arguments start and end are\n" + 
        "interpreted as in slice notation.";

    public final static String unicode_decode_doc = 
        "S.decode([encoding[,errors]]) -> string or unicode\n" + 
        "\n" + 
        "Decodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "as well as any other name registerd with codecs.register_error that is\n" + 
        "able to handle UnicodeDecodeErrors.";

    public final static String unicode_encode_doc = 
        "S.encode([encoding[,errors]]) -> string or unicode\n" + 
        "\n" + 
        "Encodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n" + 
        "'xmlcharrefreplace' as well as any other name registered with\n" + 
        "codecs.register_error that can handle UnicodeEncodeErrors.";

    public final static String unicode_endswith_doc = 
        "S.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "suffix can also be a tuple of strings to try.";

    public final static String unicode_expandtabs_doc = 
        "S.expandtabs([tabsize]) -> unicode\n" + 
        "\n" + 
        "Return a copy of S where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String unicode_find_doc = 
        "S.find(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String unicode_format_doc = 
        "S.format(*args, **kwargs) -> unicode\n" + 
        "\n" + 
        "Return a formatted version of S, using substitutions from args and kwargs.\n" + 
        "The substitutions are identified by braces ('{' and '}').";

    public final static String unicode_index_doc = 
        "S.index(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.find() but raise ValueError when the substring is not found.";

    public final static String unicode_isalnum_doc = 
        "S.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphanumeric\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_isalpha_doc = 
        "S.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphabetic\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_isdecimal_doc = 
        "S.isdecimal() -> bool\n" + 
        "\n" + 
        "Return True if there are only decimal characters in S,\n" + 
        "False otherwise.";

    public final static String unicode_isdigit_doc = 
        "S.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are digits\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_islower_doc = 
        "S.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are lowercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String unicode_isnumeric_doc = 
        "S.isnumeric() -> bool\n" + 
        "\n" + 
        "Return True if there are only numeric characters in S,\n" + 
        "False otherwise.";

    public final static String unicode_isspace_doc = 
        "S.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are whitespace\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_istitle_doc = 
        "S.istitle() -> bool\n" + 
        "\n" + 
        "Return True if S is a titlecased string and there is at least one\n" + 
        "character in S, i.e. upper- and titlecase characters may only\n" + 
        "follow uncased characters and lowercase characters only cased ones.\n" + 
        "Return False otherwise.";

    public final static String unicode_isupper_doc = 
        "S.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are uppercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String unicode_join_doc = 
        "S.join(iterable) -> unicode\n" + 
        "\n" + 
        "Return a string which is the concatenation of the strings in the\n" + 
        "iterable.  The separator between elements is S.";

    public final static String unicode_ljust_doc = 
        "S.ljust(width[, fillchar]) -> int\n" + 
        "\n" + 
        "Return S left-justified in a Unicode string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String unicode_lower_doc = 
        "S.lower() -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S converted to lowercase.";

    public final static String unicode_lstrip_doc = 
        "S.lstrip([chars]) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is a str, it will be converted to unicode before stripping";

    public final static String unicode_partition_doc = 
        "S.partition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Search for the separator sep in S, and return the part before it,\n" + 
        "the separator itself, and the part after it.  If the separator is not\n" + 
        "found, return S and two empty strings.";

    public final static String unicode_replace_doc = 
        "S.replace(old, new[, count]) -> unicode\n" + 
        "\n" + 
        "Return a copy of S with all occurrences of substring\n" + 
        "old replaced by new.  If the optional argument count is\n" + 
        "given, only the first count occurrences are replaced.";

    public final static String unicode_rfind_doc = 
        "S.rfind(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String unicode_rindex_doc = 
        "S.rindex(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.rfind() but raise ValueError when the substring is not found.";

    public final static String unicode_rjust_doc = 
        "S.rjust(width[, fillchar]) -> unicode\n" + 
        "\n" + 
        "Return S right-justified in a Unicode string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String unicode_rpartition_doc = 
        "S.rpartition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Search for the separator sep in S, starting at the end of S, and return\n" + 
        "the part before it, the separator itself, and the part after it.  If the\n" + 
        "separator is not found, return two empty strings and S.";

    public final static String unicode_rsplit_doc = 
        "S.rsplit([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in S, using sep as the\n" + 
        "delimiter string, starting at the end of the string and\n" + 
        "working to the front.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified, any whitespace string\n" + 
        "is a separator.";

    public final static String unicode_rstrip_doc = 
        "S.rstrip([chars]) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S with trailing whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is a str, it will be converted to unicode before stripping";

    public final static String unicode_split_doc = 
        "S.split([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in S, using sep as the\n" + 
        "delimiter string.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified or is None, any\n" + 
        "whitespace string is a separator and empty strings are\n" + 
        "removed from the result.";

    public final static String unicode_splitlines_doc = 
        "S.splitlines([keepends]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the lines in S, breaking at line boundaries.\n" + 
        "Line breaks are not included in the resulting list unless keepends\n" + 
        "is given and true.";

    public final static String unicode_startswith_doc = 
        "S.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "prefix can also be a tuple of strings to try.";

    public final static String unicode_strip_doc = 
        "S.strip([chars]) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading and trailing\n" + 
        "whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is a str, it will be converted to unicode before stripping";

    public final static String unicode_swapcase_doc = 
        "S.swapcase() -> unicode\n" + 
        "\n" + 
        "Return a copy of S with uppercase characters converted to lowercase\n" + 
        "and vice versa.";

    public final static String unicode_title_doc = 
        "S.title() -> unicode\n" + 
        "\n" + 
        "Return a titlecased version of S, i.e. words start with title case\n" + 
        "characters, all remaining cased characters have lower case.";

    public final static String unicode_translate_doc = 
        "S.translate(table) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S, where all characters have been mapped\n" + 
        "through the given translation table, which must be a mapping of\n" + 
        "Unicode ordinals to Unicode ordinals, Unicode strings or None.\n" + 
        "Unmapped characters are left untouched. Characters mapped to None\n" + 
        "are deleted.";

    public final static String unicode_upper_doc = 
        "S.upper() -> unicode\n" + 
        "\n" + 
        "Return a copy of S converted to uppercase.";

    public final static String unicode_zfill_doc = 
        "S.zfill(width) -> unicode\n" + 
        "\n" + 
        "Pad a numeric string S with zeros on the left, to fill a field\n" + 
        "of the specified width. The string S is never truncated.";

    // Docs for <type 'dict'>
    public final static String dict___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String dict___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String dict___contains___doc = 
        "D.__contains__(k) -> True if D has a key k, else False";

    public final static String dict___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String dict___delitem___doc = 
        "x.__delitem__(y) <==> del x[y]";

    public final static String dict_doc = 
        "dict() -> new empty dictionary\n" + 
        "dict(mapping) -> new dictionary initialized from a mapping object's\n" + 
        "    (key, value) pairs\n" + 
        "dict(iterable) -> new dictionary initialized as if via:\n" + 
        "    d = {}\n" + 
        "    for k, v in iterable:\n" + 
        "        d[k] = v\n" + 
        "dict(**kwargs) -> new dictionary initialized with the name=value pairs\n" + 
        "    in the keyword argument list.  For example:  dict(one=1, two=2)";

    public final static String dict___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String dict___format___doc = 
        "default object formatter";

    public final static String dict___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String dict___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String dict___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String dict___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String dict___hash___doc = 
        "";

    public final static String dict___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String dict___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String dict___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String dict___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String dict___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String dict___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String dict___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String dict___reduce___doc = 
        "helper for pickle";

    public final static String dict___reduce_ex___doc = 
        "helper for pickle";

    public final static String dict___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String dict___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String dict___setitem___doc = 
        "x.__setitem__(i, y) <==> x[i]=y";

    public final static String dict___sizeof___doc = 
        "D.__sizeof__() -> size of D in memory, in bytes";

    public final static String dict___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String dict___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String dict_clear_doc = 
        "D.clear() -> None.  Remove all items from D.";

    public final static String dict_copy_doc = 
        "D.copy() -> a shallow copy of D";

    public final static String dict_fromkeys_doc = 
        "dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v.\n" + 
        "v defaults to None.";

    public final static String dict_get_doc = 
        "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.";

    public final static String dict_has_key_doc = 
        "D.has_key(k) -> True if D has a key k, else False";

    public final static String dict_items_doc = 
        "D.items() -> list of D's (key, value) pairs, as 2-tuples";

    public final static String dict_iteritems_doc = 
        "D.iteritems() -> an iterator over the (key, value) items of D";

    public final static String dict_iterkeys_doc = 
        "D.iterkeys() -> an iterator over the keys of D";

    public final static String dict_itervalues_doc = 
        "D.itervalues() -> an iterator over the values of D";

    public final static String dict_keys_doc = 
        "D.keys() -> list of D's keys";

    public final static String dict_pop_doc = 
        "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n" + 
        "If key is not found, d is returned if given, otherwise KeyError is raised";

    public final static String dict_popitem_doc = 
        "D.popitem() -> (k, v), remove and return some (key, value) pair as a\n" + 
        "2-tuple; but raise KeyError if D is empty.";

    public final static String dict_setdefault_doc = 
        "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D";

    public final static String dict_update_doc = 
        "D.update(E, **F) -> None.  Update D from dict/iterable E and F.\n" + 
        "If E has a .keys() method, does:     for k in E: D[k] = E[k]\n" + 
        "If E lacks .keys() method, does:     for (k, v) in E: D[k] = v\n" + 
        "In either case, this is followed by: for k in F: D[k] = F[k]";

    public final static String dict_values_doc = 
        "D.values() -> list of D's values";

    public final static String dict_viewitems_doc = 
        "D.viewitems() -> a set-like object providing a view on D's items";

    public final static String dict_viewkeys_doc = 
        "D.viewkeys() -> a set-like object providing a view on D's keys";

    public final static String dict_viewvalues_doc = 
        "D.viewvalues() -> an object providing a view on D's values";

    // Docs for <type 'list'>
    public final static String list___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String list___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String list___contains___doc = 
        "x.__contains__(y) <==> y in x";

    public final static String list___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String list___delitem___doc = 
        "x.__delitem__(y) <==> del x[y]";

    public final static String list___delslice___doc = 
        "x.__delslice__(i, j) <==> del x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String list_doc = 
        "list() -> new empty list\n" + 
        "list(iterable) -> new list initialized from iterable's items";

    public final static String list___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String list___format___doc = 
        "default object formatter";

    public final static String list___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String list___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String list___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String list___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String list___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String list___hash___doc = 
        "";

    public final static String list___iadd___doc = 
        "x.__iadd__(y) <==> x+=y";

    public final static String list___imul___doc = 
        "x.__imul__(y) <==> x*=y";

    public final static String list___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String list___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String list___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String list___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String list___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String list___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String list___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String list___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String list___reduce___doc = 
        "helper for pickle";

    public final static String list___reduce_ex___doc = 
        "helper for pickle";

    public final static String list___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String list___reversed___doc = 
        "L.__reversed__() -- return a reverse iterator over the list";

    public final static String list___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String list___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String list___setitem___doc = 
        "x.__setitem__(i, y) <==> x[i]=y";

    public final static String list___setslice___doc = 
        "x.__setslice__(i, j, y) <==> x[i:j]=y\n" + 
        "           \n" + 
        "           Use  of negative indices is not supported.";

    public final static String list___sizeof___doc = 
        "L.__sizeof__() -- size of L in memory, in bytes";

    public final static String list___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String list___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String list_append_doc = 
        "L.append(object) -- append object to end";

    public final static String list_count_doc = 
        "L.count(value) -> integer -- return number of occurrences of value";

    public final static String list_extend_doc = 
        "L.extend(iterable) -- extend list by appending elements from the iterable";

    public final static String list_index_doc = 
        "L.index(value, [start, [stop]]) -> integer -- return first index of value.\n" + 
        "Raises ValueError if the value is not present.";

    public final static String list_insert_doc = 
        "L.insert(index, object) -- insert object before index";

    public final static String list_pop_doc = 
        "L.pop([index]) -> item -- remove and return item at index (default last).\n" + 
        "Raises IndexError if list is empty or index is out of range.";

    public final static String list_remove_doc = 
        "L.remove(value) -- remove first occurrence of value.\n" + 
        "Raises ValueError if the value is not present.";

    public final static String list_reverse_doc = 
        "L.reverse() -- reverse *IN PLACE*";

    public final static String list_sort_doc = 
        "L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;\n" + 
        "cmp(x, y) -> -1, 0, 1";

    // Docs for <type 'slice'>
    public final static String slice___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String slice___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String slice___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String slice_doc = 
        "slice([start,] stop[, step])\n" + 
        "\n" + 
        "Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).";

    public final static String slice___format___doc = 
        "default object formatter";

    public final static String slice___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String slice___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String slice___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String slice___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String slice___reduce___doc = 
        "Return state information for pickling.";

    public final static String slice___reduce_ex___doc = 
        "helper for pickle";

    public final static String slice___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String slice___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String slice___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String slice___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String slice___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String slice_indices_doc = 
        "S.indices(len) -> (start, stop, stride)\n" + 
        "\n" + 
        "Assuming a sequence of length len, calculate the start and stop\n" + 
        "indices, and the stride length of the extended slice described by\n" + 
        "S. Out of bounds indices are clipped in a manner consistent with the\n" + 
        "handling of normal slices.";

    public final static String slice_start_doc = 
        "";

    public final static String slice_step_doc = 
        "";

    public final static String slice_stop_doc = 
        "";

    // Docs for <type 'super'>
    public final static String super___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String super___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String super_doc = 
        "super(type) -> unbound super object\n" + 
        "super(type, obj) -> bound super object; requires isinstance(obj, type)\n" + 
        "super(type, type2) -> bound super object; requires issubclass(type2, type)\n" + 
        "Typical use to call a cooperative superclass method:\n" + 
        "class C(B):\n" + 
        "    def meth(self, arg):\n" + 
        "        super(C, self).meth(arg)";

    public final static String super___format___doc = 
        "default object formatter";

    public final static String super___get___doc = 
        "descr.__get__(obj[, type]) -> value";

    public final static String super___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String super___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String super___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String super___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String super___reduce___doc = 
        "helper for pickle";

    public final static String super___reduce_ex___doc = 
        "helper for pickle";

    public final static String super___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String super___self___doc = 
        "the instance invoking super(); may be None";

    public final static String super___self_class___doc = 
        "the type of the instance invoking super(); may be None";

    public final static String super___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String super___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String super___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String super___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String super___thisclass___doc = 
        "the class invoking super()";

    // Docs for <type 'staticmethod'>
    public final static String staticmethod___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String staticmethod___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String staticmethod_doc = 
        "staticmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a static method.\n" + 
        "\n" + 
        "A static method does not receive an implicit first argument.\n" + 
        "To declare a static method, use this idiom:\n" + 
        "\n" + 
        "     class C:\n" + 
        "     def f(arg1, arg2, ...): ...\n" + 
        "     f = staticmethod(f)\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "\n" + 
        "Static methods in Python are similar to those found in Java or C++.\n" + 
        "For a more advanced concept, see the classmethod builtin.";

    public final static String staticmethod___format___doc = 
        "default object formatter";

    public final static String staticmethod___func___doc = 
        "";

    public final static String staticmethod___get___doc = 
        "descr.__get__(obj[, type]) -> value";

    public final static String staticmethod___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String staticmethod___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String staticmethod___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String staticmethod___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String staticmethod___reduce___doc = 
        "helper for pickle";

    public final static String staticmethod___reduce_ex___doc = 
        "helper for pickle";

    public final static String staticmethod___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String staticmethod___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String staticmethod___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String staticmethod___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String staticmethod___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <type 'float'>
    public final static String float___abs___doc = 
        "x.__abs__() <==> abs(x)";

    public final static String float___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String float___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String float___coerce___doc = 
        "x.__coerce__(y) <==> coerce(x, y)";

    public final static String float___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String float___div___doc = 
        "x.__div__(y) <==> x/y";

    public final static String float___divmod___doc = 
        "x.__divmod__(y) <==> divmod(x, y)";

    public final static String float_doc = 
        "float(x) -> floating point number\n" + 
        "\n" + 
        "Convert a string or number to a floating point number, if possible.";

    public final static String float___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String float___float___doc = 
        "x.__float__() <==> float(x)";

    public final static String float___floordiv___doc = 
        "x.__floordiv__(y) <==> x//y";

    public final static String float___format___doc = 
        "float.__format__(format_spec) -> string\n" + 
        "\n" + 
        "Formats the float according to format_spec.";

    public final static String float___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String float___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String float___getformat___doc = 
        "float.__getformat__(typestr) -> string\n" + 
        "\n" + 
        "You probably don't want to use this function.  It exists mainly to be\n" + 
        "used in Python's test suite.\n" + 
        "\n" + 
        "typestr must be 'double' or 'float'.  This function returns whichever of\n" + 
        "'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the\n" + 
        "format of floating point numbers used by the C type named by typestr.";

    public final static String float___getnewargs___doc = 
        "";

    public final static String float___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String float___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String float___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String float___int___doc = 
        "x.__int__() <==> int(x)";

    public final static String float___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String float___long___doc = 
        "x.__long__() <==> long(x)";

    public final static String float___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String float___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String float___mul___doc = 
        "x.__mul__(y) <==> x*y";

    public final static String float___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String float___neg___doc = 
        "x.__neg__() <==> -x";

    public final static String float___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String float___nonzero___doc = 
        "x.__nonzero__() <==> x != 0";

    public final static String float___pos___doc = 
        "x.__pos__() <==> +x";

    public final static String float___pow___doc = 
        "x.__pow__(y[, z]) <==> pow(x, y[, z])";

    public final static String float___radd___doc = 
        "x.__radd__(y) <==> y+x";

    public final static String float___rdiv___doc = 
        "x.__rdiv__(y) <==> y/x";

    public final static String float___rdivmod___doc = 
        "x.__rdivmod__(y) <==> divmod(y, x)";

    public final static String float___reduce___doc = 
        "helper for pickle";

    public final static String float___reduce_ex___doc = 
        "helper for pickle";

    public final static String float___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String float___rfloordiv___doc = 
        "x.__rfloordiv__(y) <==> y//x";

    public final static String float___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String float___rmul___doc = 
        "x.__rmul__(y) <==> y*x";

    public final static String float___rpow___doc = 
        "y.__rpow__(x[, z]) <==> pow(x, y[, z])";

    public final static String float___rsub___doc = 
        "x.__rsub__(y) <==> y-x";

    public final static String float___rtruediv___doc = 
        "x.__rtruediv__(y) <==> y/x";

    public final static String float___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String float___setformat___doc = 
        "float.__setformat__(typestr, fmt) -> None\n" + 
        "\n" + 
        "You probably don't want to use this function.  It exists mainly to be\n" + 
        "used in Python's test suite.\n" + 
        "\n" + 
        "typestr must be 'double' or 'float'.  fmt must be one of 'unknown',\n" + 
        "'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be\n" + 
        "one of the latter two if it appears to match the underlying C reality.\n" + 
        "\n" + 
        "Overrides the automatic determination of C-level floating point type.\n" + 
        "This affects how floats are converted to and from binary strings.";

    public final static String float___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String float___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String float___sub___doc = 
        "x.__sub__(y) <==> x-y";

    public final static String float___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String float___truediv___doc = 
        "x.__truediv__(y) <==> x/y";

    public final static String float___trunc___doc = 
        "Returns the Integral closest to x between 0 and x.";

    public final static String float_as_integer_ratio_doc = 
        "float.as_integer_ratio() -> (int, int)\n" + 
        "\n" + 
        "Returns a pair of integers, whose ratio is exactly equal to the original\n" + 
        "float and with a positive denominator.\n" + 
        "Raises OverflowError on infinities and a ValueError on NaNs.\n" + 
        "\n" + 
        ">>> (10.0).as_integer_ratio()\n" + 
        "(10, 1)\n" + 
        ">>> (0.0).as_integer_ratio()\n" + 
        "(0, 1)\n" + 
        ">>> (-.25).as_integer_ratio()\n" + 
        "(-1, 4)";

    public final static String float_conjugate_doc = 
        "Returns self, the complex conjugate of any float.";

    public final static String float_fromhex_doc = 
        "float.fromhex(string) -> float\n" + 
        "\n" + 
        "Create a floating-point number from a hexadecimal string.\n" + 
        ">>> float.fromhex('0x1.ffffp10')\n" + 
        "2047.984375\n" + 
        ">>> float.fromhex('-0x1p-1074')\n" + 
        "-4.9406564584124654e-324";

    public final static String float_hex_doc = 
        "float.hex() -> string\n" + 
        "\n" + 
        "Return a hexadecimal representation of a floating-point number.\n" + 
        ">>> (-0.1).hex()\n" + 
        "'-0x1.999999999999ap-4'\n" + 
        ">>> 3.14159.hex()\n" + 
        "'0x1.921f9f01b866ep+1'";

    public final static String float_imag_doc = 
        "the imaginary part of a complex number";

    public final static String float_is_integer_doc = 
        "Returns True if the float is an integer.";

    public final static String float_real_doc = 
        "the real part of a complex number";

    // Docs for <type 'enumerate'>
    public final static String enumerate___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String enumerate___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String enumerate_doc = 
        "enumerate(iterable[, start]) -> iterator for index, value of iterable\n" + 
        "\n" + 
        "Return an enumerate object.  iterable must be another object that supports\n" + 
        "iteration.  The enumerate object yields pairs containing a count (from\n" + 
        "start, which defaults to zero) and a value yielded by the iterable argument.\n" + 
        "enumerate is useful for obtaining an indexed list:\n" + 
        "    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...";

    public final static String enumerate___format___doc = 
        "default object formatter";

    public final static String enumerate___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String enumerate___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String enumerate___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String enumerate___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String enumerate___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String enumerate___reduce___doc = 
        "helper for pickle";

    public final static String enumerate___reduce_ex___doc = 
        "helper for pickle";

    public final static String enumerate___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String enumerate___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String enumerate___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String enumerate___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String enumerate___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String enumerate_next_doc = 
        "x.next() -> the next value, or raise StopIteration";

    // Docs for <type 'basestring'>
    public final static String basestring___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String basestring___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String basestring_doc = 
        "Type basestring cannot be instantiated; it is the base for str and unicode.";

    public final static String basestring___format___doc = 
        "default object formatter";

    public final static String basestring___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String basestring___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String basestring___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String basestring___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String basestring___reduce___doc = 
        "helper for pickle";

    public final static String basestring___reduce_ex___doc = 
        "helper for pickle";

    public final static String basestring___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String basestring___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String basestring___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String basestring___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String basestring___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <type 'long'>
    public final static String long___abs___doc = 
        "x.__abs__() <==> abs(x)";

    public final static String long___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String long___and___doc = 
        "x.__and__(y) <==> x&y";

    public final static String long___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String long___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String long___coerce___doc = 
        "x.__coerce__(y) <==> coerce(x, y)";

    public final static String long___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String long___div___doc = 
        "x.__div__(y) <==> x/y";

    public final static String long___divmod___doc = 
        "x.__divmod__(y) <==> divmod(x, y)";

    public final static String long_doc = 
        "long(x[, base]) -> integer\n" + 
        "\n" + 
        "Convert a string or number to a long integer, if possible.  A floating\n" + 
        "point argument will be truncated towards zero (this does not include a\n" + 
        "string representation of a floating point number!)  When converting a\n" + 
        "string, use the optional base.  It is an error to supply a base when\n" + 
        "converting a non-string.";

    public final static String long___float___doc = 
        "x.__float__() <==> float(x)";

    public final static String long___floordiv___doc = 
        "x.__floordiv__(y) <==> x//y";

    public final static String long___format___doc = 
        "";

    public final static String long___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String long___getnewargs___doc = 
        "";

    public final static String long___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String long___hex___doc = 
        "x.__hex__() <==> hex(x)";

    public final static String long___index___doc = 
        "x[y:z] <==> x[y.__index__():z.__index__()]";

    public final static String long___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String long___int___doc = 
        "x.__int__() <==> int(x)";

    public final static String long___invert___doc = 
        "x.__invert__() <==> ~x";

    public final static String long___long___doc = 
        "x.__long__() <==> long(x)";

    public final static String long___lshift___doc = 
        "x.__lshift__(y) <==> x<<y";

    public final static String long___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String long___mul___doc = 
        "x.__mul__(y) <==> x*y";

    public final static String long___neg___doc = 
        "x.__neg__() <==> -x";

    public final static String long___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String long___nonzero___doc = 
        "x.__nonzero__() <==> x != 0";

    public final static String long___oct___doc = 
        "x.__oct__() <==> oct(x)";

    public final static String long___or___doc = 
        "x.__or__(y) <==> x|y";

    public final static String long___pos___doc = 
        "x.__pos__() <==> +x";

    public final static String long___pow___doc = 
        "x.__pow__(y[, z]) <==> pow(x, y[, z])";

    public final static String long___radd___doc = 
        "x.__radd__(y) <==> y+x";

    public final static String long___rand___doc = 
        "x.__rand__(y) <==> y&x";

    public final static String long___rdiv___doc = 
        "x.__rdiv__(y) <==> y/x";

    public final static String long___rdivmod___doc = 
        "x.__rdivmod__(y) <==> divmod(y, x)";

    public final static String long___reduce___doc = 
        "helper for pickle";

    public final static String long___reduce_ex___doc = 
        "helper for pickle";

    public final static String long___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String long___rfloordiv___doc = 
        "x.__rfloordiv__(y) <==> y//x";

    public final static String long___rlshift___doc = 
        "x.__rlshift__(y) <==> y<<x";

    public final static String long___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String long___rmul___doc = 
        "x.__rmul__(y) <==> y*x";

    public final static String long___ror___doc = 
        "x.__ror__(y) <==> y|x";

    public final static String long___rpow___doc = 
        "y.__rpow__(x[, z]) <==> pow(x, y[, z])";

    public final static String long___rrshift___doc = 
        "x.__rrshift__(y) <==> y>>x";

    public final static String long___rshift___doc = 
        "x.__rshift__(y) <==> x>>y";

    public final static String long___rsub___doc = 
        "x.__rsub__(y) <==> y-x";

    public final static String long___rtruediv___doc = 
        "x.__rtruediv__(y) <==> y/x";

    public final static String long___rxor___doc = 
        "x.__rxor__(y) <==> y^x";

    public final static String long___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String long___sizeof___doc = 
        "Returns size in memory, in bytes";

    public final static String long___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String long___sub___doc = 
        "x.__sub__(y) <==> x-y";

    public final static String long___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String long___truediv___doc = 
        "x.__truediv__(y) <==> x/y";

    public final static String long___trunc___doc = 
        "Truncating an Integral returns itself.";

    public final static String long___xor___doc = 
        "x.__xor__(y) <==> x^y";

    public final static String long_bit_length_doc = 
        "long.bit_length() -> int or long\n" + 
        "\n" + 
        "Number of bits necessary to represent self in binary.\n" + 
        ">>> bin(37L)\n" + 
        "'0b100101'\n" + 
        ">>> (37L).bit_length()\n" + 
        "6";

    public final static String long_conjugate_doc = 
        "Returns self, the complex conjugate of any long.";

    public final static String long_denominator_doc = 
        "the denominator of a rational number in lowest terms";

    public final static String long_imag_doc = 
        "the imaginary part of a complex number";

    public final static String long_numerator_doc = 
        "the numerator of a rational number in lowest terms";

    public final static String long_real_doc = 
        "the real part of a complex number";

    // Docs for <type 'tuple'>
    public final static String tuple___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String tuple___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String tuple___contains___doc = 
        "x.__contains__(y) <==> y in x";

    public final static String tuple___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String tuple_doc = 
        "tuple() -> empty tuple\n" + 
        "tuple(iterable) -> tuple initialized from iterable's items\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String tuple___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String tuple___format___doc = 
        "default object formatter";

    public final static String tuple___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String tuple___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String tuple___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String tuple___getnewargs___doc = 
        "";

    public final static String tuple___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String tuple___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String tuple___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String tuple___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String tuple___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String tuple___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String tuple___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String tuple___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String tuple___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String tuple___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String tuple___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String tuple___reduce___doc = 
        "helper for pickle";

    public final static String tuple___reduce_ex___doc = 
        "helper for pickle";

    public final static String tuple___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String tuple___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String tuple___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String tuple___sizeof___doc = 
        "T.__sizeof__() -- size of T in memory, in bytes";

    public final static String tuple___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String tuple___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String tuple_count_doc = 
        "T.count(value) -> integer -- return number of occurrences of value";

    public final static String tuple_index_doc = 
        "T.index(value, [start, [stop]]) -> integer -- return first index of value.\n" + 
        "Raises ValueError if the value is not present.";

    // Docs for <type 'str'>
    public final static String str___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String str___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String str___contains___doc = 
        "x.__contains__(y) <==> y in x";

    public final static String str___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String str_doc = 
        "str(object) -> string\n" + 
        "\n" + 
        "Return a nice string representation of the object.\n" + 
        "If the argument is a string, the return value is the same object.";

    public final static String str___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String str___format___doc = 
        "S.__format__(format_spec) -> string\n" + 
        "\n" + 
        "Return a formatted version of S as described by format_spec.";

    public final static String str___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String str___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String str___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String str___getnewargs___doc = 
        "";

    public final static String str___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String str___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String str___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String str___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String str___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String str___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String str___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String str___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String str___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String str___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String str___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String str___reduce___doc = 
        "helper for pickle";

    public final static String str___reduce_ex___doc = 
        "helper for pickle";

    public final static String str___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String str___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String str___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String str___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String str___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String str___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String str___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String str__formatter_field_name_split_doc = 
        "";

    public final static String str__formatter_parser_doc = 
        "";

    public final static String str_capitalize_doc = 
        "S.capitalize() -> string\n" + 
        "\n" + 
        "Return a copy of the string S with only its first character\n" + 
        "capitalized.";

    public final static String str_center_doc = 
        "S.center(width[, fillchar]) -> string\n" + 
        "\n" + 
        "Return S centered in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String str_count_doc = 
        "S.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of substring sub in\n" + 
        "string S[start:end].  Optional arguments start and end are interpreted\n" + 
        "as in slice notation.";

    public final static String str_decode_doc = 
        "S.decode([encoding[,errors]]) -> object\n" + 
        "\n" + 
        "Decodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "as well as any other name registered with codecs.register_error that is\n" + 
        "able to handle UnicodeDecodeErrors.";

    public final static String str_encode_doc = 
        "S.encode([encoding[,errors]]) -> object\n" + 
        "\n" + 
        "Encodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n" + 
        "'xmlcharrefreplace' as well as any other name registered with\n" + 
        "codecs.register_error that is able to handle UnicodeEncodeErrors.";

    public final static String str_endswith_doc = 
        "S.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "suffix can also be a tuple of strings to try.";

    public final static String str_expandtabs_doc = 
        "S.expandtabs([tabsize]) -> string\n" + 
        "\n" + 
        "Return a copy of S where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String str_find_doc = 
        "S.find(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_format_doc = 
        "S.format(*args, **kwargs) -> string\n" + 
        "\n" + 
        "Return a formatted version of S, using substitutions from args and kwargs.\n" + 
        "The substitutions are identified by braces ('{' and '}').";

    public final static String str_index_doc = 
        "S.index(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.find() but raise ValueError when the substring is not found.";

    public final static String str_isalnum_doc = 
        "S.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphanumeric\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_isalpha_doc = 
        "S.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphabetic\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_isdigit_doc = 
        "S.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are digits\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_islower_doc = 
        "S.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are lowercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String str_isspace_doc = 
        "S.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are whitespace\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_istitle_doc = 
        "S.istitle() -> bool\n" + 
        "\n" + 
        "Return True if S is a titlecased string and there is at least one\n" + 
        "character in S, i.e. uppercase characters may only follow uncased\n" + 
        "characters and lowercase characters only cased ones. Return False\n" + 
        "otherwise.";

    public final static String str_isupper_doc = 
        "S.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are uppercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String str_join_doc = 
        "S.join(iterable) -> string\n" + 
        "\n" + 
        "Return a string which is the concatenation of the strings in the\n" + 
        "iterable.  The separator between elements is S.";

    public final static String str_ljust_doc = 
        "S.ljust(width[, fillchar]) -> string\n" + 
        "\n" + 
        "Return S left-justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String str_lower_doc = 
        "S.lower() -> string\n" + 
        "\n" + 
        "Return a copy of the string S converted to lowercase.";

    public final static String str_lstrip_doc = 
        "S.lstrip([chars]) -> string or unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is unicode, S will be converted to unicode before stripping";

    public final static String str_partition_doc = 
        "S.partition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Search for the separator sep in S, and return the part before it,\n" + 
        "the separator itself, and the part after it.  If the separator is not\n" + 
        "found, return S and two empty strings.";

    public final static String str_replace_doc = 
        "S.replace(old, new[, count]) -> string\n" + 
        "\n" + 
        "Return a copy of string S with all occurrences of substring\n" + 
        "old replaced by new.  If the optional argument count is\n" + 
        "given, only the first count occurrences are replaced.";

    public final static String str_rfind_doc = 
        "S.rfind(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_rindex_doc = 
        "S.rindex(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.rfind() but raise ValueError when the substring is not found.";

    public final static String str_rjust_doc = 
        "S.rjust(width[, fillchar]) -> string\n" + 
        "\n" + 
        "Return S right-justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String str_rpartition_doc = 
        "S.rpartition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Search for the separator sep in S, starting at the end of S, and return\n" + 
        "the part before it, the separator itself, and the part after it.  If the\n" + 
        "separator is not found, return two empty strings and S.";

    public final static String str_rsplit_doc = 
        "S.rsplit([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in the string S, using sep as the\n" + 
        "delimiter string, starting at the end of the string and working\n" + 
        "to the front.  If maxsplit is given, at most maxsplit splits are\n" + 
        "done. If sep is not specified or is None, any whitespace string\n" + 
        "is a separator.";

    public final static String str_rstrip_doc = 
        "S.rstrip([chars]) -> string or unicode\n" + 
        "\n" + 
        "Return a copy of the string S with trailing whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is unicode, S will be converted to unicode before stripping";

    public final static String str_split_doc = 
        "S.split([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in the string S, using sep as the\n" + 
        "delimiter string.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified or is None, any\n" + 
        "whitespace string is a separator and empty strings are removed\n" + 
        "from the result.";

    public final static String str_splitlines_doc = 
        "S.splitlines([keepends]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the lines in S, breaking at line boundaries.\n" + 
        "Line breaks are not included in the resulting list unless keepends\n" + 
        "is given and true.";

    public final static String str_startswith_doc = 
        "S.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "prefix can also be a tuple of strings to try.";

    public final static String str_strip_doc = 
        "S.strip([chars]) -> string or unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading and trailing\n" + 
        "whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is unicode, S will be converted to unicode before stripping";

    public final static String str_swapcase_doc = 
        "S.swapcase() -> string\n" + 
        "\n" + 
        "Return a copy of the string S with uppercase characters\n" + 
        "converted to lowercase and vice versa.";

    public final static String str_title_doc = 
        "S.title() -> string\n" + 
        "\n" + 
        "Return a titlecased version of S, i.e. words start with uppercase\n" + 
        "characters, all remaining cased characters have lowercase.";

    public final static String str_translate_doc = 
        "S.translate(table [,deletechars]) -> string\n" + 
        "\n" + 
        "Return a copy of the string S, where all characters occurring\n" + 
        "in the optional argument deletechars are removed, and the\n" + 
        "remaining characters have been mapped through the given\n" + 
        "translation table, which must be a string of length 256.";

    public final static String str_upper_doc = 
        "S.upper() -> string\n" + 
        "\n" + 
        "Return a copy of the string S converted to uppercase.";

    public final static String str_zfill_doc = 
        "S.zfill(width) -> string\n" + 
        "\n" + 
        "Pad a numeric string S with zeros on the left, to fill a field\n" + 
        "of the specified width.  The string S is never truncated.";

    // Docs for <type 'property'>
    public final static String property___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String property___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String property___delete___doc = 
        "descr.__delete__(obj)";

    public final static String property_doc = 
        "property(fget=None, fset=None, fdel=None, doc=None) -> property attribute\n" + 
        "\n" + 
        "fget is a function to be used for getting an attribute value, and likewise\n" + 
        "fset is a function for setting, and fdel a function for del'ing, an\n" + 
        "attribute.  Typical use is to define a managed attribute x:\n" + 
        "class C(object):\n" + 
        "    def getx(self): return self._x\n" + 
        "    def setx(self, value): self._x = value\n" + 
        "    def delx(self): del self._x\n" + 
        "    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n" + 
        "\n" + 
        "Decorators make defining new properties or modifying existing ones easy:\n" + 
        "class C(object):\n" + 
        "    @property\n" + 
        "    def x(self): return self._x\n" + 
        "    @x.setter\n" + 
        "    def x(self, value): self._x = value\n" + 
        "    @x.deleter\n" + 
        "    def x(self): del self._x\n" + 
        "";

    public final static String property___format___doc = 
        "default object formatter";

    public final static String property___get___doc = 
        "descr.__get__(obj[, type]) -> value";

    public final static String property___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String property___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String property___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String property___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String property___reduce___doc = 
        "helper for pickle";

    public final static String property___reduce_ex___doc = 
        "helper for pickle";

    public final static String property___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String property___set___doc = 
        "descr.__set__(obj, value)";

    public final static String property___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String property___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String property___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String property___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String property_deleter_doc = 
        "Descriptor to change the deleter on a property.";

    public final static String property_fdel_doc = 
        "";

    public final static String property_fget_doc = 
        "";

    public final static String property_fset_doc = 
        "";

    public final static String property_getter_doc = 
        "Descriptor to change the getter on a property.";

    public final static String property_setter_doc = 
        "Descriptor to change the setter on a property.";

    // Docs for <type 'int'>
    public final static String int___abs___doc = 
        "x.__abs__() <==> abs(x)";

    public final static String int___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String int___and___doc = 
        "x.__and__(y) <==> x&y";

    public final static String int___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String int___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String int___coerce___doc = 
        "x.__coerce__(y) <==> coerce(x, y)";

    public final static String int___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String int___div___doc = 
        "x.__div__(y) <==> x/y";

    public final static String int___divmod___doc = 
        "x.__divmod__(y) <==> divmod(x, y)";

    public final static String int_doc = 
        "int(x[, base]) -> integer\n" + 
        "\n" + 
        "Convert a string or number to an integer, if possible.  A floating point\n" + 
        "argument will be truncated towards zero (this does not include a string\n" + 
        "representation of a floating point number!)  When converting a string, use\n" + 
        "the optional base.  It is an error to supply a base when converting a\n" + 
        "non-string.  If base is zero, the proper base is guessed based on the\n" + 
        "string content.  If the argument is outside the integer range a\n" + 
        "long object will be returned instead.";

    public final static String int___float___doc = 
        "x.__float__() <==> float(x)";

    public final static String int___floordiv___doc = 
        "x.__floordiv__(y) <==> x//y";

    public final static String int___format___doc = 
        "";

    public final static String int___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String int___getnewargs___doc = 
        "";

    public final static String int___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String int___hex___doc = 
        "x.__hex__() <==> hex(x)";

    public final static String int___index___doc = 
        "x[y:z] <==> x[y.__index__():z.__index__()]";

    public final static String int___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String int___int___doc = 
        "x.__int__() <==> int(x)";

    public final static String int___invert___doc = 
        "x.__invert__() <==> ~x";

    public final static String int___long___doc = 
        "x.__long__() <==> long(x)";

    public final static String int___lshift___doc = 
        "x.__lshift__(y) <==> x<<y";

    public final static String int___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String int___mul___doc = 
        "x.__mul__(y) <==> x*y";

    public final static String int___neg___doc = 
        "x.__neg__() <==> -x";

    public final static String int___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String int___nonzero___doc = 
        "x.__nonzero__() <==> x != 0";

    public final static String int___oct___doc = 
        "x.__oct__() <==> oct(x)";

    public final static String int___or___doc = 
        "x.__or__(y) <==> x|y";

    public final static String int___pos___doc = 
        "x.__pos__() <==> +x";

    public final static String int___pow___doc = 
        "x.__pow__(y[, z]) <==> pow(x, y[, z])";

    public final static String int___radd___doc = 
        "x.__radd__(y) <==> y+x";

    public final static String int___rand___doc = 
        "x.__rand__(y) <==> y&x";

    public final static String int___rdiv___doc = 
        "x.__rdiv__(y) <==> y/x";

    public final static String int___rdivmod___doc = 
        "x.__rdivmod__(y) <==> divmod(y, x)";

    public final static String int___reduce___doc = 
        "helper for pickle";

    public final static String int___reduce_ex___doc = 
        "helper for pickle";

    public final static String int___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String int___rfloordiv___doc = 
        "x.__rfloordiv__(y) <==> y//x";

    public final static String int___rlshift___doc = 
        "x.__rlshift__(y) <==> y<<x";

    public final static String int___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String int___rmul___doc = 
        "x.__rmul__(y) <==> y*x";

    public final static String int___ror___doc = 
        "x.__ror__(y) <==> y|x";

    public final static String int___rpow___doc = 
        "y.__rpow__(x[, z]) <==> pow(x, y[, z])";

    public final static String int___rrshift___doc = 
        "x.__rrshift__(y) <==> y>>x";

    public final static String int___rshift___doc = 
        "x.__rshift__(y) <==> x>>y";

    public final static String int___rsub___doc = 
        "x.__rsub__(y) <==> y-x";

    public final static String int___rtruediv___doc = 
        "x.__rtruediv__(y) <==> y/x";

    public final static String int___rxor___doc = 
        "x.__rxor__(y) <==> y^x";

    public final static String int___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String int___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String int___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String int___sub___doc = 
        "x.__sub__(y) <==> x-y";

    public final static String int___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String int___truediv___doc = 
        "x.__truediv__(y) <==> x/y";

    public final static String int___trunc___doc = 
        "Truncating an Integral returns itself.";

    public final static String int___xor___doc = 
        "x.__xor__(y) <==> x^y";

    public final static String int_bit_length_doc = 
        "int.bit_length() -> int\n" + 
        "\n" + 
        "Number of bits necessary to represent self in binary.\n" + 
        ">>> bin(37)\n" + 
        "'0b100101'\n" + 
        ">>> (37).bit_length()\n" + 
        "6";

    public final static String int_conjugate_doc = 
        "Returns self, the complex conjugate of any int.";

    public final static String int_denominator_doc = 
        "the denominator of a rational number in lowest terms";

    public final static String int_imag_doc = 
        "the imaginary part of a complex number";

    public final static String int_numerator_doc = 
        "the numerator of a rational number in lowest terms";

    public final static String int_real_doc = 
        "the real part of a complex number";

    // Docs for <type 'range'>
    public final static String range___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String range___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String range_doc = 
        "range([start,] stop[, step]) -> range object\n" + 
        "\n" + 
        "Like range(), but instead of returning a list, returns an object that\n" + 
        "generates the numbers in the range on demand.  For looping, this is \n" + 
        "slightly faster than range() and more memory efficient.";

    public final static String range___format___doc = 
        "default object formatter";

    public final static String range___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String range___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String range___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String range___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String range___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String range___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String range___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String range___reduce___doc = 
        "";

    public final static String range___reduce_ex___doc = 
        "helper for pickle";

    public final static String range___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String range___reversed___doc = 
        "Returns a reverse iterator.";

    public final static String range___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String range___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String range___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String range___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <type 'file'>
    public final static String file___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String file___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String file_doc = 
        "file(name[, mode[, buffering]]) -> file object\n" + 
        "\n" + 
        "Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),\n" + 
        "writing or appending.  The file will be created if it doesn't exist\n" + 
        "when opened for writing or appending; it will be truncated when\n" + 
        "opened for writing.  Add a 'b' to the mode for binary files.\n" + 
        "Add a '+' to the mode to allow simultaneous reading and writing.\n" + 
        "If the buffering argument is given, 0 means unbuffered, 1 means line\n" + 
        "buffered, and larger numbers specify the buffer size.  The preferred way\n" + 
        "to open a file is with the builtin open() function.\n" + 
        "Add a 'U' to mode to open the file for input with universal newline\n" + 
        "support.  Any line ending in the input file will be seen as a '\\n'\n" + 
        "in Python.  Also, a file so opened gains the attribute 'newlines';\n" + 
        "the value for this attribute is one of None (no newline read yet),\n" + 
        "'\\r', '\\n', '\\r\\n' or a tuple containing all the newline types seen.\n" + 
        "\n" + 
        "'U' cannot be combined with 'w' or '+' mode.\n" + 
        "";

    public final static String file___enter___doc = 
        "__enter__() -> self.";

    public final static String file___exit___doc = 
        "__exit__(*excinfo) -> None.  Closes the file.";

    public final static String file___format___doc = 
        "default object formatter";

    public final static String file___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String file___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String file___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String file___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String file___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String file___reduce___doc = 
        "helper for pickle";

    public final static String file___reduce_ex___doc = 
        "helper for pickle";

    public final static String file___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String file___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String file___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String file___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String file___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String file_close_doc = 
        "close() -> None or (perhaps) an integer.  Close the file.\n" + 
        "\n" + 
        "Sets data attribute .closed to True.  A closed file cannot be used for\n" + 
        "further I/O operations.  close() may be called more than once without\n" + 
        "error.  Some kinds of file objects (for example, opened by popen())\n" + 
        "may return an exit status upon closing.";

    public final static String file_closed_doc = 
        "True if the file is closed";

    public final static String file_encoding_doc = 
        "file encoding";

    public final static String file_errors_doc = 
        "Unicode error handler";

    public final static String file_fileno_doc = 
        "fileno() -> integer \"file descriptor\".\n" + 
        "\n" + 
        "This is needed for lower-level file interfaces, such os.read().";

    public final static String file_flush_doc = 
        "flush() -> None.  Flush the internal I/O buffer.";

    public final static String file_isatty_doc = 
        "isatty() -> true or false.  True if the file is connected to a tty device.";

    public final static String file_mode_doc = 
        "file mode ('r', 'U', 'w', 'a', possibly with 'b' or '+' added)";

    public final static String file_name_doc = 
        "file name";

    public final static String file_newlines_doc = 
        "end-of-line convention used in this file";

    public final static String file_next_doc = 
        "x.next() -> the next value, or raise StopIteration";

    public final static String file_read_doc = 
        "read([size]) -> read at most size bytes, returned as a string.\n" + 
        "\n" + 
        "If the size argument is negative or omitted, read until EOF is reached.\n" + 
        "Notice that when in non-blocking mode, less data than what was requested\n" + 
        "may be returned, even if no size parameter was given.";

    public final static String file_readinto_doc = 
        "readinto() -> Undocumented.  Don't use this; it may go away.";

    public final static String file_readline_doc = 
        "readline([size]) -> next line from the file, as a string.\n" + 
        "\n" + 
        "Retain newline.  A non-negative size argument limits the maximum\n" + 
        "number of bytes to return (an incomplete line may be returned then).\n" + 
        "Return an empty string at EOF.";

    public final static String file_readlines_doc = 
        "readlines([size]) -> list of strings, each a line from the file.\n" + 
        "\n" + 
        "Call readline() repeatedly and return a list of the lines so read.\n" + 
        "The optional size argument, if given, is an approximate bound on the\n" + 
        "total number of bytes in the lines returned.";

    public final static String file_seek_doc = 
        "seek(offset[, whence]) -> None.  Move to new file position.\n" + 
        "\n" + 
        "Argument offset is a byte count.  Optional argument whence defaults to\n" + 
        "0 (offset from start of file, offset should be >= 0); other values are 1\n" + 
        "(move relative to current position, positive or negative), and 2 (move\n" + 
        "relative to end of file, usually negative, although many platforms allow\n" + 
        "seeking beyond the end of a file).  If the file is opened in text mode,\n" + 
        "only offsets returned by tell() are legal.  Use of other offsets causes\n" + 
        "undefined behavior.\n" + 
        "Note that not all file objects are seekable.";

    public final static String file_softspace_doc = 
        "flag indicating that a space needs to be printed; used by print";

    public final static String file_tell_doc = 
        "tell() -> current file position, an integer (may be a long integer).";

    public final static String file_truncate_doc = 
        "truncate([size]) -> None.  Truncate the file to at most size bytes.\n" + 
        "\n" + 
        "Size defaults to the current file position, as returned by tell().";

    public final static String file_write_doc = 
        "write(str) -> None.  Write string str to file.\n" + 
        "\n" + 
        "Note that due to buffering, flush() or close() may be needed before\n" + 
        "the file on disk reflects the data written.";

    public final static String file_writelines_doc = 
        "writelines(sequence_of_strings) -> None.  Write the strings to the file.\n" + 
        "\n" + 
        "Note that newlines are not added.  The sequence can be any iterable object\n" + 
        "producing strings. This is equivalent to calling write() for each string.";

    public final static String file_xreadlines_doc = 
        "xreadlines() -> returns self.\n" + 
        "\n" + 
        "For backward compatibility. File objects now include the performance\n" + 
        "optimizations previously implemented in the xreadlines module.";

    // Docs for <type 'complex'>
    public final static String complex___abs___doc = 
        "x.__abs__() <==> abs(x)";

    public final static String complex___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String complex___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String complex___coerce___doc = 
        "x.__coerce__(y) <==> coerce(x, y)";

    public final static String complex___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String complex___div___doc = 
        "x.__div__(y) <==> x/y";

    public final static String complex___divmod___doc = 
        "x.__divmod__(y) <==> divmod(x, y)";

    public final static String complex_doc = 
        "complex(real[, imag]) -> complex number\n" + 
        "\n" + 
        "Create a complex number from a real part and an optional imaginary part.\n" + 
        "This is equivalent to (real + imag*1j) where imag defaults to 0.";

    public final static String complex___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String complex___float___doc = 
        "x.__float__() <==> float(x)";

    public final static String complex___floordiv___doc = 
        "x.__floordiv__(y) <==> x//y";

    public final static String complex___format___doc = 
        "complex.__format__() -> str\n" + 
        "\n" + 
        "Converts to a string according to format_spec.";

    public final static String complex___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String complex___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String complex___getnewargs___doc = 
        "";

    public final static String complex___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String complex___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String complex___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String complex___int___doc = 
        "x.__int__() <==> int(x)";

    public final static String complex___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String complex___long___doc = 
        "x.__long__() <==> long(x)";

    public final static String complex___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String complex___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String complex___mul___doc = 
        "x.__mul__(y) <==> x*y";

    public final static String complex___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String complex___neg___doc = 
        "x.__neg__() <==> -x";

    public final static String complex___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String complex___nonzero___doc = 
        "x.__nonzero__() <==> x != 0";

    public final static String complex___pos___doc = 
        "x.__pos__() <==> +x";

    public final static String complex___pow___doc = 
        "x.__pow__(y[, z]) <==> pow(x, y[, z])";

    public final static String complex___radd___doc = 
        "x.__radd__(y) <==> y+x";

    public final static String complex___rdiv___doc = 
        "x.__rdiv__(y) <==> y/x";

    public final static String complex___rdivmod___doc = 
        "x.__rdivmod__(y) <==> divmod(y, x)";

    public final static String complex___reduce___doc = 
        "helper for pickle";

    public final static String complex___reduce_ex___doc = 
        "helper for pickle";

    public final static String complex___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String complex___rfloordiv___doc = 
        "x.__rfloordiv__(y) <==> y//x";

    public final static String complex___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String complex___rmul___doc = 
        "x.__rmul__(y) <==> y*x";

    public final static String complex___rpow___doc = 
        "y.__rpow__(x[, z]) <==> pow(x, y[, z])";

    public final static String complex___rsub___doc = 
        "x.__rsub__(y) <==> y-x";

    public final static String complex___rtruediv___doc = 
        "x.__rtruediv__(y) <==> y/x";

    public final static String complex___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String complex___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String complex___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String complex___sub___doc = 
        "x.__sub__(y) <==> x-y";

    public final static String complex___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String complex___truediv___doc = 
        "x.__truediv__(y) <==> x/y";

    public final static String complex_conjugate_doc = 
        "complex.conjugate() -> complex\n" + 
        "\n" + 
        "Returns the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.";

    public final static String complex_imag_doc = 
        "the imaginary part of a complex number";

    public final static String complex_real_doc = 
        "the real part of a complex number";

    // Docs for <type 'bool'>
    public final static String bool___abs___doc = 
        "x.__abs__() <==> abs(x)";

    public final static String bool___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String bool___and___doc = 
        "x.__and__(y) <==> x&y";

    public final static String bool___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bool___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String bool___coerce___doc = 
        "x.__coerce__(y) <==> coerce(x, y)";

    public final static String bool___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String bool___div___doc = 
        "x.__div__(y) <==> x/y";

    public final static String bool___divmod___doc = 
        "x.__divmod__(y) <==> divmod(x, y)";

    public final static String bool_doc = 
        "bool(x) -> bool\n" + 
        "\n" + 
        "Returns True when the argument x is true, False otherwise.\n" + 
        "The builtins True and False are the only two instances of the class bool.\n" + 
        "The class bool is a subclass of the class int, and cannot be subclassed.";

    public final static String bool___float___doc = 
        "x.__float__() <==> float(x)";

    public final static String bool___floordiv___doc = 
        "x.__floordiv__(y) <==> x//y";

    public final static String bool___format___doc = 
        "";

    public final static String bool___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String bool___getnewargs___doc = 
        "";

    public final static String bool___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String bool___hex___doc = 
        "x.__hex__() <==> hex(x)";

    public final static String bool___index___doc = 
        "x[y:z] <==> x[y.__index__():z.__index__()]";

    public final static String bool___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String bool___int___doc = 
        "x.__int__() <==> int(x)";

    public final static String bool___invert___doc = 
        "x.__invert__() <==> ~x";

    public final static String bool___long___doc = 
        "x.__long__() <==> long(x)";

    public final static String bool___lshift___doc = 
        "x.__lshift__(y) <==> x<<y";

    public final static String bool___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String bool___mul___doc = 
        "x.__mul__(y) <==> x*y";

    public final static String bool___neg___doc = 
        "x.__neg__() <==> -x";

    public final static String bool___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String bool___nonzero___doc = 
        "x.__nonzero__() <==> x != 0";

    public final static String bool___oct___doc = 
        "x.__oct__() <==> oct(x)";

    public final static String bool___or___doc = 
        "x.__or__(y) <==> x|y";

    public final static String bool___pos___doc = 
        "x.__pos__() <==> +x";

    public final static String bool___pow___doc = 
        "x.__pow__(y[, z]) <==> pow(x, y[, z])";

    public final static String bool___radd___doc = 
        "x.__radd__(y) <==> y+x";

    public final static String bool___rand___doc = 
        "x.__rand__(y) <==> y&x";

    public final static String bool___rdiv___doc = 
        "x.__rdiv__(y) <==> y/x";

    public final static String bool___rdivmod___doc = 
        "x.__rdivmod__(y) <==> divmod(y, x)";

    public final static String bool___reduce___doc = 
        "helper for pickle";

    public final static String bool___reduce_ex___doc = 
        "helper for pickle";

    public final static String bool___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String bool___rfloordiv___doc = 
        "x.__rfloordiv__(y) <==> y//x";

    public final static String bool___rlshift___doc = 
        "x.__rlshift__(y) <==> y<<x";

    public final static String bool___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String bool___rmul___doc = 
        "x.__rmul__(y) <==> y*x";

    public final static String bool___ror___doc = 
        "x.__ror__(y) <==> y|x";

    public final static String bool___rpow___doc = 
        "y.__rpow__(x[, z]) <==> pow(x, y[, z])";

    public final static String bool___rrshift___doc = 
        "x.__rrshift__(y) <==> y>>x";

    public final static String bool___rshift___doc = 
        "x.__rshift__(y) <==> x>>y";

    public final static String bool___rsub___doc = 
        "x.__rsub__(y) <==> y-x";

    public final static String bool___rtruediv___doc = 
        "x.__rtruediv__(y) <==> y/x";

    public final static String bool___rxor___doc = 
        "x.__rxor__(y) <==> y^x";

    public final static String bool___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String bool___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String bool___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String bool___sub___doc = 
        "x.__sub__(y) <==> x-y";

    public final static String bool___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bool___truediv___doc = 
        "x.__truediv__(y) <==> x/y";

    public final static String bool___trunc___doc = 
        "Truncating an Integral returns itself.";

    public final static String bool___xor___doc = 
        "x.__xor__(y) <==> x^y";

    public final static String bool_bit_length_doc = 
        "int.bit_length() -> int\n" + 
        "\n" + 
        "Number of bits necessary to represent self in binary.\n" + 
        ">>> bin(37)\n" + 
        "'0b100101'\n" + 
        ">>> (37).bit_length()\n" + 
        "6";

    public final static String bool_conjugate_doc = 
        "Returns self, the complex conjugate of any int.";

    public final static String bool_denominator_doc = 
        "the denominator of a rational number in lowest terms";

    public final static String bool_imag_doc = 
        "the imaginary part of a complex number";

    public final static String bool_numerator_doc = 
        "the numerator of a rational number in lowest terms";

    public final static String bool_real_doc = 
        "the real part of a complex number";

    // Docs for <type 'classmethod'>
    public final static String classmethod___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String classmethod___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String classmethod_doc = 
        "classmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a class method.\n" + 
        "\n" + 
        "A class method receives the class as implicit first argument,\n" + 
        "just like an instance method receives the instance.\n" + 
        "To declare a class method, use this idiom:\n" + 
        "\n" + 
        "  class C:\n" + 
        "      def f(cls, arg1, arg2, ...): ...\n" + 
        "      f = classmethod(f)\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "If a class method is called for a derived class, the derived class\n" + 
        "object is passed as the implied first argument.\n" + 
        "\n" + 
        "Class methods are different than C++ or Java static methods.\n" + 
        "If you want those, see the staticmethod builtin.";

    public final static String classmethod___format___doc = 
        "default object formatter";

    public final static String classmethod___func___doc = 
        "";

    public final static String classmethod___get___doc = 
        "descr.__get__(obj[, type]) -> value";

    public final static String classmethod___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String classmethod___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String classmethod___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String classmethod___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String classmethod___reduce___doc = 
        "helper for pickle";

    public final static String classmethod___reduce_ex___doc = 
        "helper for pickle";

    public final static String classmethod___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String classmethod___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String classmethod___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String classmethod___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String classmethod___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <type 'set'>
    public final static String set___and___doc = 
        "x.__and__(y) <==> x&y";

    public final static String set___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String set___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String set___contains___doc = 
        "x.__contains__(y) <==> y in x.";

    public final static String set___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String set_doc = 
        "set() -> new empty set object\n" + 
        "set(iterable) -> new set object\n" + 
        "\n" + 
        "Build an unordered collection of unique elements.";

    public final static String set___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String set___format___doc = 
        "default object formatter";

    public final static String set___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String set___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String set___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String set___hash___doc = 
        "";

    public final static String set___iand___doc = 
        "x.__iand__(y) <==> x&y";

    public final static String set___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String set___ior___doc = 
        "x.__ior__(y) <==> x|y";

    public final static String set___isub___doc = 
        "x.__isub__(y) <==> x-y";

    public final static String set___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String set___ixor___doc = 
        "x.__ixor__(y) <==> x^y";

    public final static String set___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String set___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String set___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String set___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String set___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String set___or___doc = 
        "x.__or__(y) <==> x|y";

    public final static String set___rand___doc = 
        "x.__rand__(y) <==> y&x";

    public final static String set___reduce___doc = 
        "Return state information for pickling.";

    public final static String set___reduce_ex___doc = 
        "helper for pickle";

    public final static String set___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String set___ror___doc = 
        "x.__ror__(y) <==> y|x";

    public final static String set___rsub___doc = 
        "x.__rsub__(y) <==> y-x";

    public final static String set___rxor___doc = 
        "x.__rxor__(y) <==> y^x";

    public final static String set___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String set___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String set___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String set___sub___doc = 
        "x.__sub__(y) <==> x-y";

    public final static String set___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String set___xor___doc = 
        "x.__xor__(y) <==> x^y";

    public final static String set_add_doc = 
        "Add an element to a set.\n" + 
        "\n" + 
        "This has no effect if the element is already present.";

    public final static String set_clear_doc = 
        "Remove all elements from this set.";

    public final static String set_copy_doc = 
        "Return a shallow copy of a set.";

    public final static String set_difference_doc = 
        "Return the difference of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in this set but not the others.)";

    public final static String set_difference_update_doc = 
        "Remove all elements of another set from this set.";

    public final static String set_discard_doc = 
        "Remove an element from a set if it is a member.\n" + 
        "\n" + 
        "If the element is not a member, do nothing.";

    public final static String set_intersection_doc = 
        "Return the intersection of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. elements that are common to all of the sets.)";

    public final static String set_intersection_update_doc = 
        "Update a set with the intersection of itself and another.";

    public final static String set_isdisjoint_doc = 
        "Return True if two sets have a null intersection.";

    public final static String set_issubset_doc = 
        "Report whether another set contains this set.";

    public final static String set_issuperset_doc = 
        "Report whether this set contains another set.";

    public final static String set_pop_doc = 
        "Remove and return an arbitrary set element.\n" + 
        "Raises KeyError if the set is empty.";

    public final static String set_remove_doc = 
        "Remove an element from a set; it must be a member.\n" + 
        "\n" + 
        "If the element is not a member, raise a KeyError.";

    public final static String set_symmetric_difference_doc = 
        "Return the symmetric difference of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in exactly one of the sets.)";

    public final static String set_symmetric_difference_update_doc = 
        "Update a set with the symmetric difference of itself and another.";

    public final static String set_union_doc = 
        "Return the union of sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in either set.)";

    public final static String set_update_doc = 
        "Update a set with the union of itself and others.";

    // Docs for <type 'frozenset'>
    public final static String frozenset___and___doc = 
        "x.__and__(y) <==> x&y";

    public final static String frozenset___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String frozenset___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String frozenset___contains___doc = 
        "x.__contains__(y) <==> y in x.";

    public final static String frozenset___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String frozenset_doc = 
        "frozenset() -> empty frozenset object\n" + 
        "frozenset(iterable) -> frozenset object\n" + 
        "\n" + 
        "Build an immutable unordered collection of unique elements.";

    public final static String frozenset___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String frozenset___format___doc = 
        "default object formatter";

    public final static String frozenset___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String frozenset___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String frozenset___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String frozenset___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String frozenset___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String frozenset___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String frozenset___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String frozenset___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String frozenset___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String frozenset___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String frozenset___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String frozenset___or___doc = 
        "x.__or__(y) <==> x|y";

    public final static String frozenset___rand___doc = 
        "x.__rand__(y) <==> y&x";

    public final static String frozenset___reduce___doc = 
        "Return state information for pickling.";

    public final static String frozenset___reduce_ex___doc = 
        "helper for pickle";

    public final static String frozenset___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String frozenset___ror___doc = 
        "x.__ror__(y) <==> y|x";

    public final static String frozenset___rsub___doc = 
        "x.__rsub__(y) <==> y-x";

    public final static String frozenset___rxor___doc = 
        "x.__rxor__(y) <==> y^x";

    public final static String frozenset___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String frozenset___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String frozenset___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String frozenset___sub___doc = 
        "x.__sub__(y) <==> x-y";

    public final static String frozenset___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String frozenset___xor___doc = 
        "x.__xor__(y) <==> x^y";

    public final static String frozenset_copy_doc = 
        "Return a shallow copy of a set.";

    public final static String frozenset_difference_doc = 
        "Return the difference of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in this set but not the others.)";

    public final static String frozenset_intersection_doc = 
        "Return the intersection of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. elements that are common to all of the sets.)";

    public final static String frozenset_isdisjoint_doc = 
        "Return True if two sets have a null intersection.";

    public final static String frozenset_issubset_doc = 
        "Report whether another set contains this set.";

    public final static String frozenset_issuperset_doc = 
        "Report whether this set contains another set.";

    public final static String frozenset_symmetric_difference_doc = 
        "Return the symmetric difference of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in exactly one of the sets.)";

    public final static String frozenset_union_doc = 
        "Return the union of sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in either set.)";

    // Docs for <type 'exceptions.BaseException'>
    public final static String BaseException___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String BaseException___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String BaseException___dict___doc = 
        "";

    public final static String BaseException_doc = 
        "Common base class for all exceptions";

    public final static String BaseException___format___doc = 
        "default object formatter";

    public final static String BaseException___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String BaseException___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String BaseException___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String BaseException___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String BaseException___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String BaseException___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String BaseException___reduce___doc = 
        "";

    public final static String BaseException___reduce_ex___doc = 
        "helper for pickle";

    public final static String BaseException___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String BaseException___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String BaseException___setstate___doc = 
        "";

    public final static String BaseException___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String BaseException___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String BaseException___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String BaseException___unicode___doc = 
        "";

    public final static String BaseException_args_doc = 
        "";

    public final static String BaseException_message_doc = 
        "";

    // Docs for <type 'bytearray'>
    public final static String bytearray___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String bytearray___alloc___doc = 
        "B.__alloc__() -> int\n" + 
        "\n" + 
        "Returns the number of bytes actually allocated.";

    public final static String bytearray___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bytearray___contains___doc = 
        "x.__contains__(y) <==> y in x";

    public final static String bytearray___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String bytearray___delitem___doc = 
        "x.__delitem__(y) <==> del x[y]";

    public final static String bytearray_doc = 
        "bytearray(iterable_of_ints) -> bytearray.\n" + 
        "bytearray(string, encoding[, errors]) -> bytearray.\n" + 
        "bytearray(bytes_or_bytearray) -> mutable copy of bytes_or_bytearray.\n" + 
        "bytearray(memory_view) -> bytearray.\n" + 
        "\n" + 
        "Construct an mutable bytearray object from:\n" + 
        "  - an iterable yielding integers in range(256)\n" + 
        "  - a text string encoded using the specified encoding\n" + 
        "  - a bytes or a bytearray object\n" + 
        "  - any object implementing the buffer API.\n" + 
        "\n" + 
        "bytearray(int) -> bytearray.\n" + 
        "\n" + 
        "Construct a zero-initialized bytearray of the given length.";

    public final static String bytearray___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String bytearray___format___doc = 
        "default object formatter";

    public final static String bytearray___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String bytearray___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String bytearray___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String bytearray___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String bytearray___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String bytearray___iadd___doc = 
        "x.__iadd__(y) <==> x+=y";

    public final static String bytearray___imul___doc = 
        "x.__imul__(y) <==> x*=y";

    public final static String bytearray___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String bytearray___iter___doc = 
        "x.__iter__() <==> iter(x)";

    public final static String bytearray___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String bytearray___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String bytearray___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String bytearray___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String bytearray___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String bytearray___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String bytearray___reduce___doc = 
        "Return state information for pickling.";

    public final static String bytearray___reduce_ex___doc = 
        "helper for pickle";

    public final static String bytearray___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String bytearray___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String bytearray___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String bytearray___setitem___doc = 
        "x.__setitem__(i, y) <==> x[i]=y";

    public final static String bytearray___sizeof___doc = 
        "B.__sizeof__() -> int\n" + 
        " \n" + 
        "Returns the size of B in memory, in bytes";

    public final static String bytearray___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String bytearray___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bytearray_append_doc = 
        "B.append(int) -> None\n" + 
        "\n" + 
        "Append a single item to the end of B.";

    public final static String bytearray_capitalize_doc = 
        "B.capitalize() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with only its first character capitalized (ASCII)\n" + 
        "and the rest lower-cased.";

    public final static String bytearray_center_doc = 
        "B.center(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B centered in a string of length width.  Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytearray_count_doc = 
        "B.count(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of subsection sub in\n" + 
        "bytes B[start:end].  Optional arguments start and end are interpreted\n" + 
        "as in slice notation.";

    public final static String bytearray_decode_doc = 
        "B.decode([encoding[, errors]]) -> unicode object.\n" + 
        "\n" + 
        "Decodes B using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme.  Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeDecodeError.  Other possible values are 'ignore' and 'replace'\n" + 
        "as well as any other name registered with codecs.register_error that is\n" + 
        "able to handle UnicodeDecodeErrors.";

    public final static String bytearray_endswith_doc = 
        "B.endswith(suffix [,start [,end]]) -> bool\n" + 
        "\n" + 
        "Return True if B ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "suffix can also be a tuple of strings to try.";

    public final static String bytearray_expandtabs_doc = 
        "B.expandtabs([tabsize]) -> copy of B\n" + 
        "\n" + 
        "Return a copy of B where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String bytearray_extend_doc = 
        "B.extend(iterable int) -> None\n" + 
        "\n" + 
        "Append all the elements from the iterator or sequence to the\n" + 
        "end of B.";

    public final static String bytearray_find_doc = 
        "B.find(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in B where subsection sub is found,\n" + 
        "such that sub is contained within s[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytearray_fromhex_doc = 
        "bytearray.fromhex(string) -> bytearray\n" + 
        "\n" + 
        "Create a bytearray object from a string of hexadecimal numbers.\n" + 
        "Spaces between two numbers are accepted.\n" + 
        "Example: bytearray.fromhex('B9 01EF') -> bytearray(b'\\xb9\\x01\\xef').";

    public final static String bytearray_index_doc = 
        "B.index(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like B.find() but raise ValueError when the subsection is not found.";

    public final static String bytearray_insert_doc = 
        "B.insert(index, int) -> None\n" + 
        "\n" + 
        "Insert a single item into the bytearray before the given index.";

    public final static String bytearray_isalnum_doc = 
        "B.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphanumeric\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_isalpha_doc = 
        "B.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphabetic\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_isdigit_doc = 
        "B.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are digits\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_islower_doc = 
        "B.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are lowercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytearray_isspace_doc = 
        "B.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are whitespace\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_istitle_doc = 
        "B.istitle() -> bool\n" + 
        "\n" + 
        "Return True if B is a titlecased string and there is at least one\n" + 
        "character in B, i.e. uppercase characters may only follow uncased\n" + 
        "characters and lowercase characters only cased ones. Return False\n" + 
        "otherwise.";

    public final static String bytearray_isupper_doc = 
        "B.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are uppercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytearray_join_doc = 
        "B.join(iterable_of_bytes) -> bytes\n" + 
        "\n" + 
        "Concatenates any number of bytearray objects, with B in between each pair.";

    public final static String bytearray_ljust_doc = 
        "B.ljust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B left justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytearray_lower_doc = 
        "B.lower() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to lowercase.";

    public final static String bytearray_lstrip_doc = 
        "B.lstrip([bytes]) -> bytearray\n" + 
        "\n" + 
        "Strip leading bytes contained in the argument.\n" + 
        "If the argument is omitted, strip leading ASCII whitespace.";

    public final static String bytearray_partition_doc = 
        "B.partition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Searches for the separator sep in B, and returns the part before it,\n" + 
        "the separator itself, and the part after it.  If the separator is not\n" + 
        "found, returns B and two empty bytearray objects.";

    public final static String bytearray_pop_doc = 
        "B.pop([index]) -> int\n" + 
        "\n" + 
        "Remove and return a single item from B. If no index\n" + 
        "argument is given, will pop the last value.";

    public final static String bytearray_remove_doc = 
        "B.remove(int) -> None\n" + 
        "\n" + 
        "Remove the first occurance of a value in B.";

    public final static String bytearray_replace_doc = 
        "B.replace(old, new[, count]) -> bytes\n" + 
        "\n" + 
        "Return a copy of B with all occurrences of subsection\n" + 
        "old replaced by new.  If the optional argument count is\n" + 
        "given, only the first count occurrences are replaced.";

    public final static String bytearray_reverse_doc = 
        "B.reverse() -> None\n" + 
        "\n" + 
        "Reverse the order of the values in B in place.";

    public final static String bytearray_rfind_doc = 
        "B.rfind(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in B where subsection sub is found,\n" + 
        "such that sub is contained within s[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytearray_rindex_doc = 
        "B.rindex(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like B.rfind() but raise ValueError when the subsection is not found.";

    public final static String bytearray_rjust_doc = 
        "B.rjust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B right justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String bytearray_rpartition_doc = 
        "B.rpartition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Searches for the separator sep in B, starting at the end of B,\n" + 
        "and returns the part before it, the separator itself, and the\n" + 
        "part after it.  If the separator is not found, returns two empty\n" + 
        "bytearray objects and B.";

    public final static String bytearray_rsplit_doc = 
        "B.rsplit(sep[, maxsplit]) -> list of bytearray\n" + 
        "\n" + 
        "Return a list of the sections in B, using sep as the delimiter,\n" + 
        "starting at the end of B and working to the front.\n" + 
        "If sep is not given, B is split on ASCII whitespace characters\n" + 
        "(space, tab, return, newline, formfeed, vertical tab).\n" + 
        "If maxsplit is given, at most maxsplit splits are done.";

    public final static String bytearray_rstrip_doc = 
        "B.rstrip([bytes]) -> bytearray\n" + 
        "\n" + 
        "Strip trailing bytes contained in the argument.\n" + 
        "If the argument is omitted, strip trailing ASCII whitespace.";

    public final static String bytearray_split_doc = 
        "B.split([sep[, maxsplit]]) -> list of bytearray\n" + 
        "\n" + 
        "Return a list of the sections in B, using sep as the delimiter.\n" + 
        "If sep is not given, B is split on ASCII whitespace characters\n" + 
        "(space, tab, return, newline, formfeed, vertical tab).\n" + 
        "If maxsplit is given, at most maxsplit splits are done.";

    public final static String bytearray_splitlines_doc = 
        "B.splitlines([keepends]) -> list of lines\n" + 
        "\n" + 
        "Return a list of the lines in B, breaking at line boundaries.\n" + 
        "Line breaks are not included in the resulting list unless keepends\n" + 
        "is given and true.";

    public final static String bytearray_startswith_doc = 
        "B.startswith(prefix [,start [,end]]) -> bool\n" + 
        "\n" + 
        "Return True if B starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "prefix can also be a tuple of strings to try.";

    public final static String bytearray_strip_doc = 
        "B.strip([bytes]) -> bytearray\n" + 
        "\n" + 
        "Strip leading and trailing bytes contained in the argument.\n" + 
        "If the argument is omitted, strip ASCII whitespace.";

    public final static String bytearray_swapcase_doc = 
        "B.swapcase() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with uppercase ASCII characters converted\n" + 
        "to lowercase ASCII and vice versa.";

    public final static String bytearray_title_doc = 
        "B.title() -> copy of B\n" + 
        "\n" + 
        "Return a titlecased version of B, i.e. ASCII words start with uppercase\n" + 
        "characters, all remaining cased characters have lowercase.";

    public final static String bytearray_translate_doc = 
        "B.translate(table[, deletechars]) -> bytearray\n" + 
        "\n" + 
        "Return a copy of B, where all characters occurring in the\n" + 
        "optional argument deletechars are removed, and the remaining\n" + 
        "characters have been mapped through the given translation\n" + 
        "table, which must be a bytes object of length 256.";

    public final static String bytearray_upper_doc = 
        "B.upper() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to uppercase.";

    public final static String bytearray_zfill_doc = 
        "B.zfill(width) -> copy of B\n" + 
        "\n" + 
        "Pad a numeric string B with zeros on the left, to fill a field\n" + 
        "of the specified width.  B is never truncated.";

    // Docs for <type 'buffer'>
    public final static String buffer___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String buffer___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String buffer___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String buffer___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String buffer___delitem___doc = 
        "x.__delitem__(y) <==> del x[y]";

    public final static String buffer___delslice___doc = 
        "x.__delslice__(i, j) <==> del x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String buffer_doc = 
        "buffer(object [, offset[, size]])\n" + 
        "\n" + 
        "Create a new buffer object which references the given object.\n" + 
        "The buffer will reference a slice of the target object from the\n" + 
        "start of the object (or at the specified offset). The slice will\n" + 
        "extend to the end of the target object (or with the specified size).";

    public final static String buffer___format___doc = 
        "default object formatter";

    public final static String buffer___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String buffer___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String buffer___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "           \n" + 
        "           Use of negative indices is not supported.";

    public final static String buffer___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String buffer___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String buffer___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String buffer___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String buffer___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String buffer___reduce___doc = 
        "helper for pickle";

    public final static String buffer___reduce_ex___doc = 
        "helper for pickle";

    public final static String buffer___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String buffer___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String buffer___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String buffer___setitem___doc = 
        "x.__setitem__(i, y) <==> x[i]=y";

    public final static String buffer___setslice___doc = 
        "x.__setslice__(i, j, y) <==> x[i:j]=y\n" + 
        "           \n" + 
        "           Use  of negative indices is not supported.";

    public final static String buffer___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String buffer___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String buffer___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <type 'memoryview'>
    public final static String memoryview___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String memoryview___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String memoryview___delitem___doc = 
        "x.__delitem__(y) <==> del x[y]";

    public final static String memoryview_doc = 
        "memoryview(object)\n" + 
        "\n" + 
        "Create a new memoryview object which references the given object.";

    public final static String memoryview___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String memoryview___format___doc = 
        "default object formatter";

    public final static String memoryview___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String memoryview___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String memoryview___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String memoryview___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String memoryview___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String memoryview___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String memoryview___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String memoryview___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String memoryview___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String memoryview___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String memoryview___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String memoryview___reduce___doc = 
        "helper for pickle";

    public final static String memoryview___reduce_ex___doc = 
        "helper for pickle";

    public final static String memoryview___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String memoryview___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String memoryview___setitem___doc = 
        "x.__setitem__(i, y) <==> x[i]=y";

    public final static String memoryview___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String memoryview___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String memoryview___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String memoryview_format_doc = 
        "";

    public final static String memoryview_itemsize_doc = 
        "";

    public final static String memoryview_ndim_doc = 
        "";

    public final static String memoryview_readonly_doc = 
        "";

    public final static String memoryview_shape_doc = 
        "";

    public final static String memoryview_strides_doc = 
        "";

    public final static String memoryview_suboffsets_doc = 
        "";

    public final static String memoryview_tobytes_doc = 
        "";

    public final static String memoryview_tolist_doc = 
        "";

    // Docs for <type 'function'>
    public final static String function___call___doc = 
        "x.__call__(...) <==> x(...)";

    public final static String function___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String function___closure___doc = 
        "";

    public final static String function___code___doc = 
        "";

    public final static String function___defaults___doc = 
        "";

    public final static String function___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String function___dict___doc = 
        "";

    public final static String function_doc = 
        "function(code, globals[, name[, argdefs[, closure]]])\n" + 
        "\n" + 
        "Create a function object from a code object and a dictionary.\n" + 
        "The optional name string overrides the name from the code object.\n" + 
        "The optional argdefs tuple specifies the default argument values.\n" + 
        "The optional closure tuple supplies the bindings for free variables.";

    public final static String function___format___doc = 
        "default object formatter";

    public final static String function___get___doc = 
        "descr.__get__(obj[, type]) -> value";

    public final static String function___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String function___globals___doc = 
        "";

    public final static String function___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String function___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String function___module___doc = 
        "str(object) -> string\n" + 
        "\n" + 
        "Return a nice string representation of the object.\n" + 
        "If the argument is a string, the return value is the same object.";

    public final static String function___name___doc = 
        "str(object) -> string\n" + 
        "\n" + 
        "Return a nice string representation of the object.\n" + 
        "If the argument is a string, the return value is the same object.";

    public final static String function___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String function___reduce___doc = 
        "helper for pickle";

    public final static String function___reduce_ex___doc = 
        "helper for pickle";

    public final static String function___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String function___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String function___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String function___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String function___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String function_func_closure_doc = 
        "";

    public final static String function_func_code_doc = 
        "";

    public final static String function_func_defaults_doc = 
        "";

    public final static String function_func_dict_doc = 
        "";

    public final static String function_func_doc_doc = 
        "";

    public final static String function_func_globals_doc = 
        "";

    public final static String function_func_name_doc = 
        "";

    // Docs for <type 'instancemethod'>
    public final static String instancemethod___call___doc = 
        "x.__call__(...) <==> x(...)";

    public final static String instancemethod___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String instancemethod___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String instancemethod___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String instancemethod_doc = 
        "instancemethod(function, instance, class)\n" + 
        "\n" + 
        "Create an instance method object.";

    public final static String instancemethod___format___doc = 
        "default object formatter";

    public final static String instancemethod___func___doc = 
        "the function (or other callable) implementing a method";

    public final static String instancemethod___get___doc = 
        "descr.__get__(obj[, type]) -> value";

    public final static String instancemethod___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String instancemethod___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String instancemethod___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String instancemethod___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String instancemethod___reduce___doc = 
        "helper for pickle";

    public final static String instancemethod___reduce_ex___doc = 
        "helper for pickle";

    public final static String instancemethod___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String instancemethod___self___doc = 
        "the instance to which a method is bound; None for unbound methods";

    public final static String instancemethod___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String instancemethod___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String instancemethod___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String instancemethod___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String instancemethod_im_class_doc = 
        "the class associated with a method";

    public final static String instancemethod_im_func_doc = 
        "the function (or other callable) implementing a method";

    public final static String instancemethod_im_self_doc = 
        "the instance to which a method is bound; None for unbound methods";

    // Docs for <type 'code'>
    public final static String code___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String code___cmp___doc = 
        "x.__cmp__(y) <==> cmp(x,y)";

    public final static String code___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String code_doc = 
        "code(argcount, nlocals, stacksize, flags, codestring, constants, names,\n" + 
        "      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])\n" + 
        "\n" + 
        "Create a code object.  Not for the faint of heart.";

    public final static String code___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String code___format___doc = 
        "default object formatter";

    public final static String code___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String code___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String code___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String code___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String code___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String code___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String code___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String code___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String code___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String code___reduce___doc = 
        "helper for pickle";

    public final static String code___reduce_ex___doc = 
        "helper for pickle";

    public final static String code___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String code___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String code___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String code___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String code___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String code_co_argcount_doc = 
        "";

    public final static String code_co_cellvars_doc = 
        "";

    public final static String code_co_code_doc = 
        "";

    public final static String code_co_consts_doc = 
        "";

    public final static String code_co_filename_doc = 
        "";

    public final static String code_co_firstlineno_doc = 
        "";

    public final static String code_co_flags_doc = 
        "";

    public final static String code_co_freevars_doc = 
        "";

    public final static String code_co_lnotab_doc = 
        "";

    public final static String code_co_name_doc = 
        "";

    public final static String code_co_names_doc = 
        "";

    public final static String code_co_nlocals_doc = 
        "";

    public final static String code_co_stacksize_doc = 
        "";

    public final static String code_co_varnames_doc = 
        "";

    // Docs for <type 'frame'>
    public final static String frame___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String frame___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String frame_doc = 
        "";

    public final static String frame___format___doc = 
        "default object formatter";

    public final static String frame___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String frame___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String frame___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String frame___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String frame___reduce___doc = 
        "helper for pickle";

    public final static String frame___reduce_ex___doc = 
        "helper for pickle";

    public final static String frame___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String frame___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String frame___sizeof___doc = 
        "F.__sizeof__() -> size of F in memory, in bytes";

    public final static String frame___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String frame___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String frame_f_back_doc = 
        "";

    public final static String frame_f_builtins_doc = 
        "";

    public final static String frame_f_code_doc = 
        "";

    public final static String frame_f_exc_traceback_doc = 
        "";

    public final static String frame_f_exc_type_doc = 
        "";

    public final static String frame_f_exc_value_doc = 
        "";

    public final static String frame_f_globals_doc = 
        "";

    public final static String frame_f_lasti_doc = 
        "";

    public final static String frame_f_lineno_doc = 
        "";

    public final static String frame_f_locals_doc = 
        "";

    public final static String frame_f_restricted_doc = 
        "";

    public final static String frame_f_trace_doc = 
        "";

    // Docs for <type 'traceback'>
    public final static String traceback___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String traceback___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String traceback_doc = 
        "";

    public final static String traceback___format___doc = 
        "default object formatter";

    public final static String traceback___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String traceback___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String traceback___init___doc = 
        "x.__init__(...) initializes x; see help(type(x)) for signature";

    public final static String traceback___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String traceback___reduce___doc = 
        "helper for pickle";

    public final static String traceback___reduce_ex___doc = 
        "helper for pickle";

    public final static String traceback___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String traceback___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String traceback___sizeof___doc = 
        "__sizeof__() -> int\n" + 
        "size of object in memory, in bytes";

    public final static String traceback___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String traceback___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String traceback_tb_frame_doc = 
        "";

    public final static String traceback_tb_lasti_doc = 
        "";

    public final static String traceback_tb_lineno_doc = 
        "";

    public final static String traceback_tb_next_doc = 
        "";

    public final static String sre_pattern_doc =
        "Compiled regular expression objects";

    public final static String sre_pattern_match_doc =
        "match(string[, pos[, endpos]]) --> match object or None.\n" +
        "    Matches zero or more characters at the beginning of the string";

    public final static String sre_pattern_findall_doc =
        "findall(string[, pos[, endpos]]) --> list.\n" +
        "   Return a list of all non-overlapping matches of pattern in string.";

    public final static String sre_pattern_finditer_doc =
        "finditer(string[, pos[, endpos]]) --> iterator.\n" +
        "    Return an iterator over all non-overlapping matches for the \n" +
        "    RE pattern in string. For each match, the iterator returns a\n" +
        "    match object.";

    public final static String sre_pattern_search_doc =
        "search(string[, pos[, endpos]]) --> match object or None.\n" +
        "    Scan through string looking for a match, and return a corresponding\n" +
        "    match object instance. Return None if no position in the string matches.";

    public final static String sre_pattern_split_doc =
        "split(string[, maxsplit = 0])  --> list.\n" +
        "    Split string by the occurrences of pattern.";

    public final static String sre_pattern_sub_doc =
        "sub(repl, string[, count = 0]) --> newstring\n" +
        "    Return the string obtained by replacing the leftmost non-overlapping\n" +
        "    occurrences of pattern in string by the replacement repl.";

    public final static String sre_pattern_subn_doc =
        "subn(repl, string[, count = 0]) --> (newstring, number of subs)\n" +
        "    Return the tuple (new_string, number_of_subs_made) found by replacing\n" +
        "    the leftmost non-overlapping occurrences of pattern with the\n" +
        "    replacement repl.";
}
